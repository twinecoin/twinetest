package org.twinecoin.test.vectors;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.twinecoin.test.crypt.SHA256;
import org.twinecoin.test.crypt.SHA512;

/**
 * Class to generate test vectors for the tw_sha256 class.<br>
 * <br>
 * This ensures that the test vectors are generated by a separate
 * implementation.
 */
public class SHATestVectors {

	public static List<String> generateVectors() {
		Random r = getRandom();

		List<String> lines = new ArrayList<String>();

		List<byte[]> messages = generateTestMessages(r);
		lines.addAll(generateSHA256Vectors(messages));

		return lines;
	}

	public static Random getRandom() {
		Random r = new Random();

		// Seed random so that results are consistent
		r.setSeed(0x280e788cff6ec2bbL);
		return r;
	}

	public static List<byte[]> generateTestMessages(Random r) {
		List<byte[]> messages = new ArrayList<byte[]>();

		/**
		 * Extremes
		 */
		messages.add(new byte[0]);
		messages.add("a".getBytes(StandardCharsets.US_ASCII));
		messages.add("ab".getBytes(StandardCharsets.US_ASCII));
		messages.add("abc".getBytes(StandardCharsets.US_ASCII));
		messages.add("The quick brown fox jumps over the lazy dog".getBytes(StandardCharsets.US_ASCII));
		messages.add("The quick brown fox jumps over the lazy dog.".getBytes(StandardCharsets.US_ASCII));

		/**
		 * Purely random vectors
		 */
		for (int i = 0; i < 500; i++) {
			int mask = (1 << (r.nextInt(10))) - 1;
			byte[] message = new byte[r.nextInt() & mask];
			r.nextBytes(message);
			messages.add(message);
		}

		return messages;
	}

	public static List<String> generateSHA256Vectors(List<byte[]> messages) {
		List<String> lines = new ArrayList<String>();

		List<byte[]> SHA256Hashes = generateHashes(messages, SHA256.getSHA256MessageDigest());
		List<byte[]> SHA512Hashes = generateHashes(messages, SHA512.getSHA512MessageDigest());
		List<byte[]> DSHA256Hashes = generateHashes(messages, SHA256.getSHA256MessageDigest());
		List<byte[]> DSHA512Hashes = generateHashes(messages, SHA512.getSHA512MessageDigest());

		lines.add("tw_u8* tw_sha_test_vector_messages[] = {");

		for (byte[] message : messages) {
			lines.add("    " + Convert.bytesToU8(false, message) + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("int tw_sha_test_vector_message_lengths[] = {");

		for (byte[] message : messages) {
			lines.add("    " + message.length + ",");
		}

		lines.add("  };");
		lines.add("");
		
		lines.add("tw_u512 tw_sha256_test_vector_hashes[] = {");

		for (byte[] hash : SHA256Hashes) {
			lines.add("    {" + Convert.bytesToU8(true, new byte[32], hash) + "},");
		}

		lines.add("  };");
		lines.add("");

		lines.add("tw_u512 tw_sha512_test_vector_hashes[] = {");

		for (byte[] hash : SHA512Hashes) {
			lines.add("    {" + Convert.bytesToU8(true, hash) + "},");
		}
		
		lines.add("  };");
		lines.add("");
		
		lines.add("tw_u512 tw_sha256_test_vector_hashes[] = {");

		for (byte[] hash : DSHA256Hashes) {
			lines.add("    {" + Convert.bytesToU8(true, hash) + "},");
		}

		lines.add("  };");
		lines.add("");

		lines.add("tw_u512 tw_sha512_test_vector_hashes[] = {");

		for (byte[] hash : DSHA512Hashes) {
			lines.add("    {" + Convert.bytesToU8(true, hash) + "},");
		}

		lines.add("  };");
		lines.add("");
		lines.add("#define SHA256_TEST_VECTORS_LENGTH " + messages.size());

		return lines;
	}
	
	private static List<byte[]> generateHashes(List<byte[]> messages, MessageDigest md) {
		List<byte[]> hashes = new ArrayList<byte[]>(messages.size());
		for (byte[] message : messages) {
			md.reset();
			byte[] hash = md.digest(message);
			hashes.add(hash);
		}
		return hashes;
	}
}