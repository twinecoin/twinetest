package org.twinecoin.test.vectors;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Class to generate test vectors for the tw_u256 class.<br>
 * <br>
 * This ensures that the test vectors are generated by a separate
 * implementation.
 */
public class U256TestVectors {

	private final static BigInteger U256_MAX = BigInteger.ONE.shiftLeft(256).subtract(BigInteger.ONE);
	private final static BigInteger U256_ZERO = BigInteger.ZERO;

	public static List<String> generateVectors() {
		Random r = getRandom();

		List<List<BigInteger>> pair = generateBigIntegerList(r);

		List<String> lines = new ArrayList<String>();

		lines.addAll(generateU256BinaryOperatorVectors(pair.get(0), pair.get(1)));
		lines.add("");
		lines.addAll(generateU256xU32BinaryOperatorVectors(r, pair.get(0)));

		return lines;
	}

	public static Random getRandom() {
		Random r = new Random();

		// Seed random so that results are consistent
		r.setSeed(0x280e788cff6ec2bbL);
		return r;
	}

	public static List<List<BigInteger>> generateBigIntegerList(Random r) {
		List<BigInteger> integerList = new ArrayList<BigInteger>();

		/**
		 * The u256 class uses 32-bit unsigned words internally.
		 *
		 * Each word is initialised to one of the following.  Words near the extremes
		 * are assumed to give errors.
		 * 
		 *   0x00000000
		 *   0x00000001
		 *   0xFFFFFFFE
		 *   0xFFFFFFFF
		 *   Random value
		 */
		int[] edgeValues = new int[] {0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF};

		int[] value = new int[8];
		for (int i = 0; i < 390625; i++) {
			int rem = i;
			for (int j = 0; j < 8; j++) {
				int option = rem % 5;
				rem /= 5;
				if (option == 4) {
					value[j] = r.nextInt();
				} else {
					value[j] = edgeValues[option];
				}
			}
			integerList.add(intToBigInteger(value));
		}

		List<BigInteger> aList = new ArrayList<BigInteger>();
		List<BigInteger> bList = new ArrayList<BigInteger>();

		/**
		 * Extremes
		 */
		aList.add(U256_ZERO);
		bList.add(U256_ZERO);

		aList.add(U256_ZERO);
		bList.add(U256_MAX);

		aList.add(U256_MAX);
		bList.add(U256_ZERO);

		aList.add(U256_MAX);
		bList.add(U256_MAX);

		/**
		 * Divide by zero
		 */
		for (int i = 0; i < 10; i++) {
			aList.add(integerList.get(r.nextInt(integerList.size())));
			bList.add(integerList.get(0));
		}

		/**
		 * Almost equal
		 */
		for (int i = 0; i < 10; i++) {
			BigInteger v = integerList.get(r.nextInt(integerList.size()));
			aList.add(v);
			bList.add(v.add(BigInteger.valueOf(i - 5)));
		}

		/**
		 * Single bit different
		 */
		for (int i = 0; i < 8; i++) {
			BigInteger ref = new BigInteger(256, r);
			aList.add(ref);
			BigInteger bit = BigInteger.ONE.shiftLeft(r.nextInt(32) + (32 * i));
			bList.add(ref.xor(bit));
		}

		/**
		 * Directed vectors
		 */
		for (int i = 0; i < 500; i++) {
			aList.add(integerList.get(r.nextInt(integerList.size())));
			bList.add(integerList.get(r.nextInt(integerList.size())));
		}

		/**
		 * Purely random vectors
		 */
		for (int i = 0; i < 500; i++) {
			aList.add(new BigInteger(256, r));
			bList.add(new BigInteger(256, r));
		}

		/**
		 * Purely random vectors, with some half width
		 */
		for (int i = 0; i < 500; i++) {
			aList.add(new BigInteger(r.nextBoolean() ? 256 : 128, r));
			bList.add(new BigInteger(r.nextBoolean() ? 256 : 128, r));
		}

		List<List<BigInteger>> pair = new ArrayList<List<BigInteger>>(2);
		pair.add(aList);
		pair.add(bList);
		return pair;
	}

	public static List<String> generateU256BinaryOperatorVectors(List<BigInteger> aList, List<BigInteger> bList) {
		List<String> lines = new ArrayList<String>();

		lines.add("typedef struct _tw_u256_test_vector_256x256 {");
		lines.add("  tw_u256 a;             // a");
		lines.add("  tw_u256 b;             // b");
		lines.add("  int a_equal_b;         // a == b");
		lines.add("  int a_comp_b;          // (a < b) ? -1 : (a == b) ? 0 : 1");
		lines.add("  tw_u256 a_add_b;       // a + b");
		lines.add("  int a_add_b_carry;     // Carry");
		lines.add("  tw_u256 a_sub_b;       // a - b");
		lines.add("  int a_sub_b_borrow;    // Borrow");
		lines.add("  tw_u256 a_mul_b;       // a * b");
		lines.add("  int a_mul_b_overflow;  // Overflow");
		lines.add("  tw_u256 a_div_b;       // a / b");
		lines.add("  tw_u256 a_rem_b;       // a / b");
		lines.add("  int div_by_0;          // divide by 0");
		lines.add("} tw_u256_test_vector_256x256;");
		lines.add("");

		lines.add("tw_u256_test_vector_256x256 u256_test_vectors_256x256[] =");
		lines.add("  {");

		String align = "                                                                                               ";

		for (int i = 0; i < aList.size(); i++) {
			BigInteger a = aList.get(i);
			BigInteger b = bList.get(i);

			BigInteger add = a.add(b);
			BigInteger sub = a.subtract(b);
			BigInteger mul = a.multiply(b);
			BigInteger div = BigInteger.ZERO.equals(b) ? BigInteger.ZERO : a.divide(b);
			BigInteger rem = BigInteger.ZERO.equals(b) ? BigInteger.ZERO : a.remainder(b);
			
			lines.add("    // Vector " + i);
			lines.add("    {");
			lines.add("      " + bigIntegerToU256(a) + ",    // a");
			lines.add("      " + bigIntegerToU256(b) + ",    // b");
			lines.add("      " + (a.equals(b) ? "1," : "0,") + align + "    // equals");
			lines.add("      " + a.compareTo(b) + "," + align + (a.compareTo(b) >= 0 ? " " : "") + "   // compare");
			lines.add("      " + bigIntegerToU256(add) + ",    // a + b");
			lines.add("      " + (add.compareTo(U256_MAX) > 0 ? 1 : 0) + "," + align + "    // carry");
			lines.add("      " + bigIntegerToU256(sub) + ",    // a - b");
			lines.add("      " + (sub.compareTo(BigInteger.ZERO) < 0 ? 1 : 0) + "," + align + "    // borrow");
			lines.add("      " + bigIntegerToU256(mul) + ",    // a * b");
			lines.add("      " + (mul.compareTo(U256_MAX) > 0 ? 1 : 0) + "," + align + "    // overflow");
			lines.add("      " + bigIntegerToU256(div) + ",    // a / b");
			lines.add("      " + bigIntegerToU256(rem) + ",    // a % b");
			lines.add("      " + (b.compareTo(BigInteger.ZERO) == 0 ? 1 : 0) + "," + align + "    // div_by_zero");
			lines.add("    " + ((i == aList.size() - 1) ? "}" : "},"));
		}
		lines.add("  };");
		lines.add("");
		lines.add("#define U256_TEST_VECTORS_256X256_LENGTH " + aList.size());
		
		return lines;		
	}
	
	public static List<String> generateU256xU32BinaryOperatorVectors(Random r, List<BigInteger> aList) {
		List<String> lines = new ArrayList<String>();
		
		lines.add("typedef struct _tw_u256_test_vector_256x32 {");
		lines.add("  tw_u256 a;             // a");
		lines.add("  tw_u32 b;              // b");
		lines.add("  tw_u32 s;              // shift (32-bit words)");
		lines.add("  tw_u256 a_mul_b;       // a * b");
		lines.add("  int a_mul_b_overflow;  // Overflow");
		lines.add("  tw_u256 a_add_b;       // a + b");
		lines.add("  int a_add_b_carry;     // Carry");
		lines.add("  tw_u256 a_sub_b;       // a - b");
		lines.add("  int a_sub_b_borrow;    // Borrow");
		lines.add("} tw_u256_test_vector_256x32;");
		lines.add("");
		
		lines.add("tw_u256_test_vector_256x32 u256_test_vectors_256x32[] =");
		lines.add("  {");
		
		String align = "                                                                                      ";
		
		int[] edgeValues = new int[] {0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF};
		
		for (int i = 0; i < aList.size(); i++) {
			BigInteger a = aList.get(i);
			long bLong;
			
			if (r.nextBoolean()) {
				bLong = r.nextInt() & 0xFFFFFFFFL;
			} else {
				bLong = edgeValues[r.nextInt(4)] & 0xFFFFFFFFL;
			}
			
			int s = r.nextInt();
			
			BigInteger b = BigInteger.valueOf(bLong);

			int maskedS = s & 0x7;
			BigInteger mul = a.multiply(b).shiftLeft(32 * maskedS);
			
			BigInteger add = a.add(b.shiftLeft(32 * maskedS));

			BigInteger sub = a.subtract(b.shiftLeft(32 * maskedS));

			lines.add("    // Vector " + i);
			lines.add("    {");
			lines.add("      " + bigIntegerToU256(a) + ",    // a");
			lines.add("      " + String.format("0x%08x", b) + "," + align + "    // b");
			lines.add("      " + String.format("0x%08x", s) + "," + align + "    // 32-bit word shifts");
			lines.add("      " + bigIntegerToU256(mul) + ",    // a * b");
			lines.add("      " + (mul.compareTo(U256_MAX) > 0 ? 1 : 0) + "," + align + "    // overflow");
			lines.add("      " + bigIntegerToU256(add) + ",    // a + b");
			lines.add("      " + (add.compareTo(U256_MAX) > 0 ? 1 : 0) + "," + align + "    // carry");
			lines.add("      " + bigIntegerToU256(sub) + ",    // a - b");
			lines.add("      " + (sub.compareTo(U256_ZERO) < 0 ? 1 : 0) + "," + align + "    // borrow");
			lines.add("    " + ((i == aList.size() - 1) ? "}" : "},"));
		}
		lines.add("  };");
		lines.add("");
		lines.add("#define U256_TEST_VECTORS_256X32_LENGTH " + aList.size());
		
		return lines;		
	}
	
	private static String bigIntegerToU256(BigInteger value) {
		BigInteger mask = BigInteger.valueOf(0x00000000FFFFFFFFL);
		
		StringBuilder buf = new StringBuilder();
		buf.append("{");
		for (int i = 256 - 32; i >= 0; i -= 32) {
			if (i < 256 - 32) {
				buf.append(", ");
			}
			long word = value.shiftRight(i).and(mask).longValue();
			buf.append(String.format("0x%08x", word));
		}
		buf.append("}");
		return buf.toString();
	}

	private static BigInteger intToBigInteger(int[] value) {
		byte[] bytes = new byte[1 + value.length * 4];
		bytes[0] = 0;
		for (int i = 0; i < value.length; i++) {
			int b = (i << 2) + 1;
			bytes[b + 0] = (byte) (value[i] >> 24);
			bytes[b + 1] = (byte) (value[i] >> 16);
			bytes[b + 2] = (byte) (value[i] >> 8);
			bytes[b + 3] = (byte) (value[i] >> 0);
		}
		return new BigInteger(bytes);
	}

}