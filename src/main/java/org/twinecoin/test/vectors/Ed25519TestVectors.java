package org.twinecoin.test.vectors;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.twinecoin.test.crypt.TwEd25519;

/**
 * Class to generate test vectors for the tw_sha256 class.<br>
 * <br>
 * This ensures that the test vectors are generated by a separate
 * implementation.
 */
public class Ed25519TestVectors {

	public static List<String> generateVectors() {
		Random r = getRandom();

		List<String> lines = new ArrayList<String>();

		lines.addAll(generateEd25519Vectors(r));

		return lines;
	}

	public static Random getRandom() {
		Random r = new Random();

		// Seed random so that results are consistent
		r.setSeed(0x280e788cff6ec2bbL);
		return r;
	}

	public static byte[][] getMessages(Random r) {
		List<byte[]> messages = new ArrayList<byte[]>();

		List<String> messageStrings = new ArrayList<String>();

		messageStrings.add("");
		messageStrings.add("a");
		messageStrings.add("ab");
		messageStrings.add("abc");
		messageStrings.add("This is a test message");

		for (String string : messageStrings) {
			messages.add(string.getBytes(StandardCharsets.US_ASCII));
		}

		for (int i = 0; i < 100; i++) {
			int length = r.nextInt(512);
			byte[] message = new byte[length];
			r.nextBytes(message);
			messages.add(message);
		}

		return messages.toArray(new byte[0][]);
	}

	public static List<String> generateEd25519Vectors(Random r) {
		List<String> lines = new ArrayList<String>();

		List<byte[]> messages = new ArrayList<byte[]>();
		List<byte[]> signatures = new ArrayList<byte[]>();
		List<byte[]> publicKeys = new ArrayList<byte[]>();
		List<Boolean> validSignatures = new ArrayList<Boolean>();

		for (byte[] message : getMessages(r)) {
			byte[] seed = new byte[32];
			r.nextBytes(seed);

			PrivateKey privateKey = TwEd25519.createPrivateKey(seed);
			PublicKey publicKey = TwEd25519.getPublicKey(privateKey);

			byte[] publicKeyBytes = TwEd25519.getPublicKeyDERBytes(publicKey);

			byte[] signature;

			try {
				Signature verifier = Signature.getInstance("EdDSA", "BC");

				verifier.initSign(privateKey);

				verifier.update(message);

				signature = verifier.sign();
			} catch (Exception e) {
				signature = null;
			}

			if (signature == null) {
				throw new IllegalStateException("Unable to sign message");
			}

			// Valid message
			messages.add(message);
			signatures.add(signature);
			publicKeys.add(publicKeyBytes);
			validSignatures.add(true);

			if (message.length > 0) {
				// Modified message
				byte[] corruptMessage = Arrays.copyOf(message, message.length);
				corruptMessage[r.nextInt(message.length)]++;
				messages.add(corruptMessage);
				signatures.add(signature);
				publicKeys.add(publicKeyBytes);
				validSignatures.add(false);
			}

			// Padded message
			byte[] paddedMessage = Arrays.copyOf(message, message.length + r.nextInt(5) + 1);
			messages.add(paddedMessage);
			signatures.add(signature);
			publicKeys.add(publicKeyBytes);
			validSignatures.add(false);

			if (signature.length > 0) {
				// Modified signature
				byte[] corruptSignature = Arrays.copyOf(signature, signature.length);
				corruptSignature[r.nextInt(signature.length)]++;
				messages.add(message);
				signatures.add(corruptSignature);
				publicKeys.add(publicKeyBytes);
				validSignatures.add(false);
			}

			// Padded signature
			byte[] paddedSignature = Arrays.copyOf(signature, signature.length + r.nextInt(5) + 1);
			messages.add(message);
			signatures.add(paddedSignature);
			publicKeys.add(publicKeyBytes);
			validSignatures.add(false);

			if (publicKeyBytes.length > 0) {
				// Modified public key
				byte[] corruptPublicKey = Arrays.copyOf(publicKeyBytes, publicKeyBytes.length);
				corruptPublicKey[2 + r.nextInt(publicKeyBytes.length - 2)]++;
				messages.add(message);
				signatures.add(signature);
				publicKeys.add(corruptPublicKey);
				validSignatures.add(false);
			}

			// Padded public key
			// Not possible, fixed at 64
		}

		lines.add("tw_u8* tw_ed25519_test_vector_messages[] = {");

		for (byte[] message : messages) {
			lines.add("    " + Convert.bytesToU8(false, message) + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("int tw_ed25519_test_vector_message_lengths[] = {");

		for (byte[] message : messages) {
			lines.add("    " + message.length + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("tw_u8* tw_ed25519_test_vector_signatures[] = {");

		for (byte[] sig : signatures) {
			lines.add("    " + Convert.bytesToU8(false, sig) + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("int tw_ed25519_test_vector_signature_lengths[] = {");

		for (byte[] sig : signatures) {
			lines.add("    " + sig.length + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("int tw_ed25519_test_vector_signature_valid[] = {");

		for (boolean validSignature : validSignatures) {
			int expected = validSignature ? 0 : -1;
			lines.add("    " + expected + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("tw_u8* tw_ed25519_test_vector_public_keys[] = {");

		for (byte[] publicKeyBytes : publicKeys) {
			lines.add("    " + Convert.bytesToU8(false, publicKeyBytes) + ",");
		}

		lines.add("  };");
		lines.add("");

		lines.add("#define ED25519_TEST_VECTORS_LENGTH " + messages.size());

		return lines;
	}
}
